README file for Programming Assignment 2 (C++ edition)
=====================================================

Your directory should contain the following files:

 Makefile
 README
 cool.flex
 test.cl
 lextest.cc      -> [cool root]/src/PA2/lextest.cc
 mycoolc         -> [cool root]/PA2/mycoolc
 stringtab.cc    -> [cool root]/PA2/stringtab.cc
 utilities.cc    -> [cool root]/PA2/utilities.cc
 handle_flags.cc -> [cool root]/PA2/handle_flags.cc
 *.d             dependency files
 *.*             other generated files

The include (.h) files for this assignment can be found in 
[cool root]/PA2

	The Makefile contains targets for compiling and running your
	program. DO NOT MODIFY.

	The README contains this info. Part of the assignment is to fill
	the README with the write-up for your project. You should
	explain design decisions, explain why your code is correct, and
	why your test cases are adequate. It is part of the assignment
	to clearly and concisely explain things in text as well as to
	comment your code. Just edit this file.

	cool.flex is a skeleton file for the specification of the
	lexical analyzer. You should complete it with your regular
	expressions, patterns and actions. 

	test.cl is a COOL program that you can test the lexical
	analyzer on. It contains some errors, so it won't compile with
	coolc. However, test.cl does not exercise all lexical
	constructs of COOL and part of your assignment is to rewrite
	test.cl with a complete set of tests for your lexical analyzer.

	cool-parse.h contains definitions that are used by almost all parts
	of the compiler. DO NOT MODIFY.

	stringtab.{cc|h} and stringtab_functions.h contains functions
        to manipulate the string tables.  DO NOT MODIFY.

	utilities.{cc|h} contains functions used by the main() part of
	the lextest program. You may want to use the strdup() function
	defined in here. Remember that you should not print anything
	from inside cool.flex! DO NOT MODIFY.

	lextest.cc contains the main function which will call your
	lexer and print out the tokens that it returns.  DO NOT MODIFY.

	mycoolc is a shell script that glues together the phases of the
	compiler using Unix pipes instead of statically linking code.  
	While inefficient, this architecture makes it easy to mix and match
	the components you write with those of the course compiler.
	DO NOT MODIFY.	

        cool-lexer.cc is the scanner generated by flex from cool.flex.
        DO NOT MODIFY IT, as your changes will be overritten the next
        time you run flex.

 	The *.d files are automatically generated Makefiles that capture
 	dependencies between source and header files in this directory.
 	These files are updated automatically by Makefile; see the gmake
 	documentation for a detailed explanation.

Instructions
------------

	To compile your lextest program type:

	% make lexer

	Run your lexer by putting your test input in a file 'foo.cl' and
	run the lextest program:

	% ./lexer foo.cl

	To run your lexer on the file test.cl type:

	% make dotest

	If you think your lexical analyzer is correct and behaves like
	the one we wrote, you can actually try 'mycoolc' and see whether
	it runs and produces correct code for any examples.
	If your lexical analyzer behaves in an
	unexpected manner, you may get errors anywhere, i.e. during
	parsing, during semantic analysis, during code generation or
	only when you run the produced code on spim. So beware.

	If you change architectures you must issue

	% make clean

	when you switch from one type of machine to the other.
	If at some point you get weird errors from the linker,	
	you probably forgot this step.

	GOOD LUCK!

---8<------8<------8<------8<---cut here---8<------8<------8<------8<---

Write-up for PA2
----------------
Design decisions
1) In the definitions section, one integers have been declared, namely noOfNestedComments which is initialized to 0. 
noOfNestedComments define the number of nested comments and are incremented
when (* comes and are decremented when *) comes. This is used to check if 
nesting of comments are properly done or not. 
2) A function writeToStringBuffer is declared which takes character as argument.
This function checks if the specified character can be added to buffer by comparing length of string buffer (string_buf_ptr - string_buf) with MAX_STR_CONST. If yes, it adds the character and increments string_buf_ptr pointer. Else, it returns ERROR.
3) Start conditions namely str, comment, dashComments, invalidstr have been defined.
4) Regular expressions for all reserved keywords, whitespaces, integers, type identifiers and object identifiers have been defined.
5) Whenever a "(*" pattern matches, state is changed to comment and noOfNestedComments is incremented. IF a "*)" pattern matches in INITIAL state, then error is displayed showing message "Unmatched *)". When in comment state, if a "(*" is matched then noOfNestedComments is incremented. If a "\n" occurs then curr_lineno is incremented. If a "*)" is matched, then noOfNestedComments is decremented, then it is checked if noOfNestedComments is < 0. If so, then it means that the comment had never begun hence error is displayed showing "Unmatched *)". If noOfNestedComments becomes 0, the state is changed to INITIAL. If EOF is matched in comment state, then error is displayed showing message "EOF in comment". All the characters other than these are being eaten up without any action.
6) If a "--" is matched, then state is changed to dashComments. If in this state, a "\n" occurs then line no is incremented and state is changed to INITIAL since the dash comment has been ended. All other characters are being eaten up with no action.
7) When a " is matched then it enters into str state and we set string_buf_ptr to string_buf that is start of the string_buf array . If EOF is encountered while in str state, then  ERROR "EOF in string constant" is displayed and state is changed to INITIAL. If an unescaped newline is encountered in this state, then ERROR "Unterminated string constant" is displayed and state is changed to initial and null character is inserted at str_buf_ptr indicating end of that string. If in this state, null character is encountered, then ERROR "String contains null character" is displayed and state is changed to invalidStr and null character is inserted at string_buf_ptr indicating end of that string. Escape sequence \c is being accepted for all characters c except for \n \t \b \f, the result is c. Hence except for \n \t \b \f, if \c is encountered then c is appended to string constant by calling function writeToBuffer. For \n, \t, \b and \f, "\n", "\t", "\b" and "\f" is being added to string buffer. For any other character that doesnt matched above things, it is simply appended to string buffer. Care has been taken that string constant doesnt contain greater than 1024 characters, hence during function call writeToBuffer, check is done to prevent that. The function's return type is integer. If it returns 0, it means string buffer has exceeded its capacity and ERROR "String constant too long" is displayed and state is changed to invalidStr and null character is inserted at str_buf_ptr indicating end of that string.
When in this state, if " occurs, then we change the state to INITIAL and assign cool_yylval.symbol as stringtable.add_string(string_buf).
8) When in invalidStr state (this indicates that either string has exceeded 1024 characters or null character has occurred in string), then in either case lexing is resumed after the end of this string that is the beginning of next line if an unescaped newline occurs or after the closing ".
Hence in this state, when " is matched, state is changed to INITIAL and if \n is matched then curr_lineno is incremented and state is changed to INITIAL and other than these if any character is matched, no action is being performed.
9) For reserved keywords, integer codes representing their syntactic category as defined in cool-parse.h is returned.
10) For single characters, their integer ASCII value is being returned.
11) For keywords true and false, care has been taken that they are case sensitive (first character lowercase) and if matched, cool_yylval.boolean is being changed accordingly and BOOL_CONST is returned.
12) For type identifiers, object identifiers, integers, their semantic value is stored in the field cool_yylval.symbol and TYPEID, OBJECTID and INT_CONST is being returned respectively.
13) Whitespace characters are being eaten up without any action being performed.
14) If a new line occurs, then curr_lineno is incremented.
15) If other than these any other character occurs, then error occurs displaying that character.
16) All basic test cases such as for ERRORS like ‘‘Unterminated string constant’’, ‘‘String constant too long’’, ‘‘EOF
in comment’’, ‘‘EOF in string constant’’, ‘‘Unmatched *)’’, for invalid characters printing the characters as error string have been checked.
17) Also errors related to nesting of comments  have been checked.
18) Also check is done if a null character or EOF occurs in string, then lexing resumes after the end of string that is after closing " or the beginning of the next line if an unescaped newline occurs.
19) Check regarding single dash comments have been done.
20) Check is done for boolean constants true and false, that is it is ensured that it must start with lowercase letter. 
